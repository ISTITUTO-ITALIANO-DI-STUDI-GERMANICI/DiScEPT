<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>TEI Alignment Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

  <tei-alignment-viewer></tei-alignment-viewer>

  <script type="module">
    class TEIAlignmentViewer extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.linkMap = new Map();
        this.colorMap = new Map();
        this.locked = new Set();
        this.showNumbers = true;
      }

      async connectedCallback() {
        // Check for static file source first
        const url = this.getAttribute('src');
        if (url) {
          const response = await fetch(url);
          const xmlText = await response.text();
          this.renderTEI(xmlText);
        }

        // Listen for TEI content via postMessage
        window.addEventListener('message', async (event) => {
          if (event.data && event.data.type === 'tei-content') {
            try {
              const response = await fetch(event.data.blobURL);
              const xmlText = await response.text();
              this.renderTEI(xmlText);
              // Clean up blob URL after loading
              URL.revokeObjectURL(event.data.blobURL);
            } catch (error) {
              console.error('Error loading TEI from blob URL:', error);
            }
          }
        });
      }

      renderTEI(xmlText) {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, "application/xml");

        const shadow = this.shadowRoot;
        const style = document.createElement("style");
        style.textContent = `
          :host {
            font-family: 'Inter', 'Roboto', sans-serif;
            display: block;
            padding: 2rem;
            max-width: 1400px;
            margin: auto;
            background: #F6F5F3;
            min-height: 100vh;
          }
          .header {
            background: #FFFFFF;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 16px;
            box-shadow: 0px 2px 12px rgba(0, 0, 0, 0.06);
          }
          .header h2 {
            color: #2E2E2E;
            margin-top: 0;
            font-weight: 600;
          }
          .header p {
            color: #6B6B6B;
            margin-bottom: 1rem;
          }
          .layout {
            display: flex;
            flex-direction: row;
            gap: 1.5rem;
          }
          .sidebar {
            width: 240px;
            background: #FFFFFF;
            border: 1px solid #E4DCCF;
            padding: 1rem;
            border-radius: 16px;
            max-height: 600px;
            overflow-y: auto;
            transition: all 0.3s ease;
            box-shadow: 0px 2px 12px rgba(0, 0, 0, 0.06);
          }
          .sidebar-toggle {
            cursor: pointer;
            background: #5E9278;
            color: white;
            border: none;
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
            border-radius: 10px;
            font-weight: 500;
            transition: background-color 0.2s;
          }
          .sidebar-toggle:hover {
            background: #4A7560;
          }
          .sidebar.minimized {
            width: 50px;
            padding: 0.5rem;
            overflow: hidden;
          }
          .sidebar.minimized a {
            display: none;
          }
          .sidebar a {
            display: block;
            font-size: 0.85rem;
            color: #5E9278;
            text-decoration: none;
            padding: 0.6rem 0.75rem;
            margin: 0.3rem 0;
            border-radius: 8px;
            border-left: 3px solid transparent;
            transition: all 0.2s;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
          }
          .sidebar a:hover {
            background: #E4DCCF;
            border-left-color: #5E9278;
            transform: translateX(2px);
          }
          .controls {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            /* border-top: 1px solid #E4DCCF; */
          }
          .controls button {
            background: #5E9278;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
          }
          .controls button:hover {
            background: #4A7560;
          }
          .cards {
            display: flex;
            flex-direction: row;
            gap: 1.5rem;
            flex: 1;
          }
          .card {
            flex: 1;
            background: #FFFFFF;
            border: 1px solid #E4DCCF;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0px 2px 12px rgba(0, 0, 0, 0.06);
          }
          .card h3 {
            margin-top: 0;
            color: #2E2E2E;
            font-weight: 600;
            padding-bottom: 1rem;
            border-bottom: 2px solid #E4DCCF;
            margin-bottom: 1rem;
          }
          .verse {
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            border-radius: 10px;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
            color: #2E2E2E;
            line-height: 1.6;
          }
          .verse:hover {
            transform: translateX(4px);
          }
          .verse.locked {
            box-shadow: inset 0 0 0 2px #5E9278;
            background: rgba(94, 146, 120, 0.1);
          }
          .verse.hovered {
            box-shadow: 0 0 0 2px #5E9278;
            background: rgba(94, 146, 120, 0.05);
          }
          .verse-number {
            position: absolute;
            left: -2rem;
            top: 0.75rem;
            font-size: 0.75rem;
            color: #6B6B6B;
            font-weight: 500;
          }
          .hide-numbers .verse-number {
            display: none;
          }
          @media (max-width: 768px) {
            .layout {
              flex-direction: column;
            }
            .cards {
              flex-direction: column;
            }
            .sidebar {
              width: 100%;
              order: -1;
            }
          }
        `;

        const wrapper = document.createElement("div");

        // Look for title/author in nested TEI documents (skip wrapper TEI)
        const nestedTEIs = xml.querySelectorAll("TEI > TEI");
        let title = "Titolo";
        let author = "Autore";

        // Try to find title/author from nested TEI documents first
        for (const tei of nestedTEIs) {
          const titleEl = tei.querySelector("teiHeader fileDesc titleStmt title") ||
                          tei.querySelector("teiHeader titleStmt title") ||
                          tei.querySelector("teiHeader title");
          const authorEl = tei.querySelector("teiHeader fileDesc titleStmt author") ||
                           tei.querySelector("teiHeader titleStmt author") ||
                           tei.querySelector("teiHeader author");

          if (titleEl && titleEl.textContent?.trim()) {
            title = titleEl.textContent.trim();
          }
          if (authorEl && authorEl.textContent?.trim()) {
            author = authorEl.textContent.trim();
          }

          // If we found both, break early
          if (title !== "Titolo" && author !== "Autore") break;
        }

        // Fallback to root TEI if nothing found in nested
        if (title === "Titolo") {
          const titleEl = xml.querySelector("teiHeader fileDesc titleStmt title") ||
                          xml.querySelector("teiHeader titleStmt title") ||
                          xml.querySelector("teiHeader title");
          if (titleEl && titleEl.textContent?.trim()) {
            title = titleEl.textContent.trim();
          }
        }
        if (author === "Autore") {
          const authorEl = xml.querySelector("teiHeader fileDesc titleStmt author") ||
                           xml.querySelector("teiHeader titleStmt author") ||
                           xml.querySelector("teiHeader author");
          if (authorEl && authorEl.textContent?.trim()) {
            author = authorEl.textContent.trim();
          }
        }

        wrapper.innerHTML = `
          <div class="header">
            <h2>${title}</h2>
            <p><em>${author}</em></p>
            <div class="controls">
              <!-- <button id="toggleNumbers">ðŸ”¢ Mostra/Nascondi numeri</button> -->
            </div>
          </div>
        `;


const palette = [
  "rgba(94, 146, 120, 0.15)",   // Sage green tint
  "rgba(228, 220, 207, 0.25)",  // Beige tint
  "rgba(94, 146, 120, 0.08)",   // Lighter sage
  "rgba(228, 220, 207, 0.15)",  // Lighter beige
  "rgba(46, 46, 46, 0.05)",     // Subtle gray
  "rgba(107, 107, 107, 0.08)",  // Medium gray tint
  "rgba(94, 146, 120, 0.20)",   // Darker sage
  "rgba(228, 220, 207, 0.30)",  // Darker beige
  "rgba(94, 146, 120, 0.10)",   // Sage variant
  "rgba(228, 220, 207, 0.20)",  // Beige variant
  "rgba(46, 46, 46, 0.08)",     // Gray variant
  "rgba(107, 107, 107, 0.05)"   // Light gray
];

        const links = Array.from(xml.querySelectorAll("linkGrp[type='translation'] > link"));
        links.forEach((link, idx) => {
          const [id1, id2] = link.getAttribute("target").split(" ").map(s => s.replace("#", ""));
          const color = palette[idx % palette.length];
          this.linkMap.set(id1, id2);
          this.linkMap.set(id2, id1);
          this.colorMap.set(id1, color);
          this.colorMap.set(id2, color);
        });

        // Select only nested TEI elements (not the root wrapper)
        const teis = xml.querySelectorAll("TEI > TEI");
        const langData = {};

        teis.forEach(tei => {
          const langElement = tei.querySelector("language");
          if (!langElement) return;

          const lang = langElement.textContent?.toLowerCase() || langElement.getAttribute("ident")?.toLowerCase();
          if (!lang) return;

          // Look for ALL text content elements (paragraphs, dates, etc.) in the text body
          const allElements = tei.querySelectorAll("text p, text date, text head");
          const verses = [];
          let elementIndex = 0;

          allElements.forEach((element) => {
            const text = element.textContent.trim();
            if (!text) return;

            // Skip if this element is contained within another element we're already processing
            const hasParentInList = Array.from(allElements).some(other =>
              other !== element && other.contains(element)
            );
            if (hasParentInList) return;

            const id = element.getAttribute("xml:id") || null;

            // Get color if aligned, or empty string if not aligned
            const color = id ? (this.colorMap.get(id) || "") : "";
            const isAligned = id ? this.colorMap.has(id) : false;

            verses.push({
              id: id || `element-${++elementIndex}`, // Generate ID for elements without one
              text,
              color,
              n: elementIndex,
              isAligned
            });
          });

          // Store by language code or full name
          if (lang.includes("it") || lang.includes("italiano")) {
            langData.it = verses;
          } else if (lang.includes("de") || lang.includes("tedesco") || lang.includes("deutsch")) {
            langData.de = verses;
          } else if (lang.includes("en") || lang.includes("english")) {
            langData.en = verses;
          } else {
            // Store with the language identifier as key
            langData[lang] = verses;
          }
        });

        const layout = document.createElement("div");
        layout.className = "layout";

        const sidebar = document.createElement("div");
        sidebar.className = "sidebar";
        const toggleBtn = document.createElement("button");
        toggleBtn.className = "sidebar-toggle";
        toggleBtn.textContent = "â‡†";
        toggleBtn.onclick = () => sidebar.classList.toggle("minimized");
        sidebar.appendChild(toggleBtn);
        links.forEach((link, idx) => {
          const targets = link.getAttribute("target");
          if (!targets) return;
          const [id1, id2] = targets.split(" ").map(s => s.replace("#", ""));

          // Try to get preview text from the elements
          const element1 = xml.querySelector(`[xml\\:id="${id1}"]`);
          let linkText = `Alignment ${idx + 1}`;
          if (element1) {
            const previewText = element1.textContent.trim().substring(0, 30);
            linkText = previewText.length > 30 ? previewText + "..." : previewText;
          }

          const a = document.createElement("a");
          a.href = `#${id1}`;
          a.textContent = linkText;
          a.title = `Scroll to alignment pair ${idx + 1}`;
          a.onclick = e => {
            e.preventDefault();
            this.scrollToVerses(id1);
          };
          sidebar.appendChild(a);
        });

        const cards = document.createElement("div");
        cards.className = "cards";

        const makeCard = (lang, label) => {
          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `<h3>${label}</h3>`;
          langData[lang].forEach(({ id, text, color, n }) => {
            const div = document.createElement("div");
            div.className = "verse";
            div.id = id;
            div.dataset.id = id;
            if (color) div.style.backgroundColor = color;
            div.innerHTML = `<span class="verse-number">${n}</span>${text}`;
            div.addEventListener("mouseenter", () => this.highlight(id, true));
            div.addEventListener("mouseleave", () => {
              if (!this.locked.has(id)) this.highlight(id, false);
            });
            div.addEventListener("click", () => {
              if (this.locked.has(id)) {
                this.locked.delete(id);
                this.highlight(id, false);
              } else {
                this.locked.add(id);
                this.highlight(id, true);
              }
            });
            card.appendChild(div);
          });
          return card;
        };

        // Create cards for each language found
        const langLabels = {
          it: "Italian Text",
          de: "German Translation",
          en: "English Translation",
          fr: "French Translation"
        };

        Object.keys(langData).forEach(lang => {
          if (langData[lang] && langData[lang].length > 0) {
            const label = langLabels[lang] || `Text (${lang})`;
            cards.appendChild(makeCard(lang, label));
          }
        });

        layout.appendChild(sidebar);
        layout.appendChild(cards);
        wrapper.appendChild(layout);
        // Clear previous content before rendering new TEI
        this.shadowRoot.innerHTML = '';

        shadow.appendChild(style);
        shadow.appendChild(wrapper);

        // Comment out toggle numbers functionality for now
        // const toggleNumbersBtn = shadow.querySelector("#toggleNumbers");
        // if (toggleNumbersBtn) {
        //   toggleNumbersBtn.onclick = () => {
        //     this.showNumbers = !this.showNumbers;
        //     shadow.querySelectorAll(".card").forEach(card => {
        //       card.classList.toggle("hide-numbers", !this.showNumbers);
        //     });
        //   };
        // }
      }

      highlight(id, on) {
        const partnerId = this.linkMap.get(id);
        const verses = [];

        // Find elements by data-id individually to avoid CSS selector issues
        const allVerses = this.shadowRoot.querySelectorAll('[data-id]');
        allVerses.forEach(verse => {
          const dataId = verse.getAttribute('data-id');
          if (dataId === id || dataId === partnerId) {
            verses.push(verse);
          }
        });

        verses.forEach(verse => verse.classList.toggle("hovered", on));
        if (on) {
          this.locked.has(id) && verses.forEach(v => v.classList.add("locked"));
        } else {
          this.locked.has(id) || verses.forEach(v => v.classList.remove("locked"));
        }
      }

      scrollToVerses(id) {
        const partnerId = this.linkMap.get(id);
        const targets = [];

        // Find elements by ID individually to avoid CSS selector issues
        const element1 = this.shadowRoot.getElementById(id);
        const element2 = partnerId ? this.shadowRoot.getElementById(partnerId) : null;

        if (element1) targets.push(element1);
        if (element2) targets.push(element2);

        targets.forEach(el => el.scrollIntoView({ behavior: "smooth", block: "center" }));
        this.highlight(id, true);
        setTimeout(() => {
          if (!this.locked.has(id)) this.highlight(id, false);
        }, 2000);
      }
    }

    customElements.define('tei-alignment-viewer', TEIAlignmentViewer);
  </script>

</body>
</html>

